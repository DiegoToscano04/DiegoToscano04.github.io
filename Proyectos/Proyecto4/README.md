<p align="center">  Elaboración Proyecto 4 Machine Language</p>

<h4 align="center">  ARQUITECTURA DE COMPUTADORES A2 </h4>


<p align="center">  WEB GRUPO ALPHA:
https://diegotoscano04.github.io/  </p>
<p align="center"> <img src= "https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/4f2cd469-f8a6-482a-8f92-33960615841e"> </p>

------------

# Aprendizaje herramienta The Nand to Tetris

## Software:
###### El paquete de software Nand to Tetris contiene todas las herramientas y archivos necesarios para completar todos los proyectos descritos en este sitio y en el libro "The Elements of Computing Systems".

## Descarga:
###### Se descarga el programa Nand2Tetris de la página web: https://www.nand2tetris.org/software
###### Una vez descargados los archivos quedará una carpeta con el nombre de `nand2tetris` con 2 subcarpetas denominadas `projects` y `tools`.
![image](https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/d058171f-9976-4289-bb46-fc4ff46c9729) ![image](https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/417ef519-6948-40a5-9c36-775b71ab4c82)

## Información sobre los archivos:
###### En la carpeta `projects` estarán los proyectos del 1 al 13 los cuales son archivos que deben modificarse para completar las prácticas mientras se trabaja en varios proyectos de nand2tetris.
###### En la carpeta `tools` estarán las herramientas del software nand2tetris.

## Uso del programa Assembler 
<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/72f725df-6dcf-4c43-a30e-e663c3258e0d" width="500" height="300" /></p>
<p align="center">Fuente: https://docs.google.com/presentation/d/1C10JSIwKVlz5WyvHzUtZkjrZpZMqe8n1/edit#slide=id.p14</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/4646403e-b677-45d1-9083-6aca9836d41c" width="500" height="300" /></p>
<p align="center">Fuente: https://docs.google.com/presentation/d/1C10JSIwKVlz5WyvHzUtZkjrZpZMqe8n1/edit#slide=id.p14</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/6bfba127-0ef7-4b41-966e-a03ee7f81ea1" width="500" height="300" /></p>
<p align="center">Fuente: https://docs.google.com/presentation/d/1C10JSIwKVlz5WyvHzUtZkjrZpZMqe8n1/edit#slide=id.p14</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/d64ca4d6-a5d8-46fe-9fb2-18695c2d61e1" width="500" height="300" /></p>
<p align="center">Fuente: https://docs.google.com/presentation/d/1C10JSIwKVlz5WyvHzUtZkjrZpZMqe8n1/edit#slide=id.p14</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/d433992f-1eb1-4ab1-b95b-65fae4dd71bf" width="500" height="300" /></p>
<p align="center">Fuente: https://docs.google.com/presentation/d/1C10JSIwKVlz5WyvHzUtZkjrZpZMqe8n1/edit#slide=id.p14</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/bece867e-716c-48a8-97df-4d7a481a05d8" width="500" height="300" /></p>
<p align="center">Fuente: https://docs.google.com/presentation/d/1C10JSIwKVlz5WyvHzUtZkjrZpZMqe8n1/edit#slide=id.p14</p>

## Uso del programa CPUEmulator
<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/831c8911-a1a7-4444-b732-23f1aa21c92a" /></p>
<p align="center">Fuente: https://docs.google.com/presentation/d/16DQsZZS9kd50JpK15QKPL8NVqf3Ic912/edit#slide=id.p9</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/bdd10740-561f-406c-9963-b4765df24ac8" width="500" height="300" /></p>
<p align="center">Fuente: https://docs.google.com/presentation/d/16DQsZZS9kd50JpK15QKPL8NVqf3Ic912/edit#slide=id.p9</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/37bb2a75-791c-4cd3-8ec4-e56d0201e0d1" width="500" height="300" /></p>
<p align="center">Fuente: https://docs.google.com/presentation/d/16DQsZZS9kd50JpK15QKPL8NVqf3Ic912/edit#slide=id.p9</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/11ee677d-e27b-4da1-b2aa-6d2e3442331f" width="500" height="300" /></p>
<p align="center">Fuente: https://docs.google.com/presentation/d/16DQsZZS9kd50JpK15QKPL8NVqf3Ic912/edit#slide=id.p9</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/27cd3171-ab6b-4e57-9050-d429f5ae0a71" width="500" height="300" /></p>
<p align="center">Fuente: https://docs.google.com/presentation/d/16DQsZZS9kd50JpK15QKPL8NVqf3Ic912/edit#slide=id.p9</p>

##### En la parte final de cada evaluación podemos corroborar con un mensaje de :`Comparison ended successfuly` si realizamos la actividad de manera satisfactoria para continuar con los pasos recomendados.

### Desarrollo Proyecto 4:

##### En este proyecto escribiremos y ejecutaremos programas de máquina de bajo nivel, se escribirán programas en el lenguaje de Hack assembly y se hará uso de de un ensamblador para traducirlos a código binario y probar el código resultante el cual estára en binario.

##### Se ejecutará el proyecto en un emulador de CPU, diseñado para ejecutar código binario escrito en en Hack assembly.


## Objetivos Generales

- Obtener una práctica de programación de bajo nivel en lenguaje de máquina.
- Familiarizarse con el conjunto de intrucciones Hack antes de construir el ordenador Hack en el proyecto 5.
- Conocer el proceso de ensamblado antes de construir el ensamblador en el proyecto 6.
------------

## Objetivos Específicos

- Escribir y testear los programas `Mult.asm` y `Fill.asm`.
- Usar editor de texto plano para realizar los programas y luego pasarlos por el programa Assambler y CPUEmulator.
-----------

## Pasos a seguir: 

0. Entrar a la carpeta de su PC donde se encuentre el archivo Xxx.asm. Inicie el ensamblador y el CPUEmulator desde la carpeta actual.
1. Use un editor de texto plano para editar el archivo Xxx.asm y guarde la nueva versión en su carpeta actual.
2. Utilice el ensamblador para traducir el archivo Xxx.asm. Si hay errores devovlerse al paso 1.
3. Guarde el archivo Xxx.hack resultante en la carpeta actual.
4. Cargue el archivo Xxx.hack en el emulador de CPU, ejecute el programa e inspeccione los valores que recibe mientras ejecuta, si tiene errorres devovlerse al paso 1.
5. Cargue el archivo Xxx.tst suministrado en el emulador de CPU y ejecútelo, si hay errores devolverse al paso 1.
-----------------------
<h3 align="center">Mult.asm</h3>

#### Multiplication Program (Mult.asm):

Las entradas de este programa son los valores actuales almacenados en R0 y R1 (es decir, las dos posiciones superiores de la RAM). El programa calcula el producto R0*R1 y almacena el resultado en R2. Asumimos (en este programa) que R0>=0, R1>=0, y R0*R1<32768. No es necesario que su programa compruebe estas condiciones, sino que asuma que se cumplen. Los scripts suministrados Mult.tst y Mult.cmp probarán su programa en varios valores de datos representativos.

##### Antes de poder ejecutarse, un programa simbólico debe traducirse a instrucciones que el ordenador pueda decodificar y ejecutar.

#### Hack instructions
<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/be76646a-f832-4bab-a8c6-e53a121e1e0a" width="500" height="300" /></p>
<p align="center">Fuente: https://drive.google.com/file/d/1HxjPmIZkFHl-BVW3qoz8eD9dqEuEyuBI/view</p>

##### El programa puede utilizar variables simbólicas según sea necesario, existe un agente que sabe cómo vincular los simbolos a las direcciones RAM sensibles, dicho agente es el ensamblador.

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/d3be8390-341b-4983-9c92-ad43c46acefc" width="350" height="200" /></p>
<p align="center">Fuente: https://drive.google.com/file/d/1HxjPmIZkFHl-BVW3qoz8eD9dqEuEyuBI/view</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/1cbe0bb8-5843-40eb-9b75-e67ba734804a" width="300" height="350" /></p>
<p align="center">Fuente: https://drive.google.com/file/d/1HxjPmIZkFHl-BVW3qoz8eD9dqEuEyuBI/view</p>

#### Cógido Mult.asm
```
// Multiplies R0 and R1 and stores the result in R2.
// (R0, R1, R2 refer to RAM[0], RAM[1], and RAM[2], respectively.)
//
// This program only needs to handle arguments that satisfy
// R0 >= 0, R1 >= 0, and R0*R1 < 32768.

@R2
M=0

@R0
D=M
@DEFAULT
D;JEQ

@R1
D=M
@DEFAULT
D;JEQ

(LOOP)
@R0
D=M
@R2
M=M+D
@R1
M=M-1

@R1
D=M

@LOOP
D;JGT

@END
D;JEQ 

(DEFAULT)
@R2
M=0
@END
0;JMP

(END)
@END
0;JMP

```
#### Procesamiento basado en punteros

##### En Hack, el acceso basado en punteros se realiza ajustando el registro de dirección a la dirección que queremos acceder.
<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/8bba477e-f5e9-4f12-b537-3c10c85a9566" width="450" height="350" /></p>
<p align="center">Fuente: https://drive.google.com/file/d/1HxjPmIZkFHl-BVW3qoz8eD9dqEuEyuBI/view</p>


#### Traductor (Ensamblador)
##### El ensamblador sustituye todos los símbolos por direcciones físicas y genera instrucciones binarias.

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/ad1a9b0e-d76f-47ba-9c3e-bdcfcf1082df" width="550" height="450" /></p>
<p align="center">Fuente: Propiedad de los autores</p>

##### Una vez pasado por el ensamblador extraemos el archivo punto hack que nos arroja.
<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/0089c929-88dc-46ad-9e60-8f92971b6f2c" /></p>
<p align="center">Fuente: Propiedad de los autores</p>

-----------------

##### Ahora usamos el programa CPUEmulator para corroborar si el codigo que hicimos y convertimos en el archivo punto hack funciona correctamente.

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/53274084-5f0d-4447-a3e0-765953dd6a37" width="450" height="350"/></p>
<p align="center">Fuente: Propiedad de los autores</p>

##### Observamos que pasó la prueba del archivo `Mult.tst` con el mensaje `Comparison ended successfully`.

-------------------------------------------

<h3 align="center">Fill.asm</h3>

#### I/O-Handling Program (Fill.asm):

Este programa ejecuta un bucle infinito que escucha la entrada del teclado. Cuando se pulsa una tecla (cualquier tecla), el programa ennegrece la pantalla, es decir, escribe ''black'' en cada píxel. Cuando no se pulsa ninguna tecla, la pantalla se limpia. Puede elegir ennegrecer y borrar la pantalla en cualquier orden espacial, siempre que se pulsa una tecla de forma continua durante el tiempo suficiente, la pantalla se ennegrecerá por completo. No pulsar ninguna tecla durante el tiempo suficiente dará como resultado una pantalla en blanco. Este programa tiene un script de prueba (Fill.tst) pero no un archivo de comparación - debe ser comprobado inspeccionando visiblemente la pantalla simulada.

El ordenador Hack interactúa con el teclado físico a través de un mapa de memoria de una sola palabra situado en la dirección RAM 24576 (0x6000). Cada vez quese pulsa una tecla en el teclado físico, su código ASCII de 16 bits aparece en RAM[24576]. Cuando no se pulsa ninguna tecla, aparece el código 0 en esta ubicación. En Además de los códigos ASCII habituales, el teclado Hack reconoce las teclas que se muestran a continuación: 

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/39f7a3cc-7b6f-438d-a99c-c5f9670fb454" /></p>
<p align="center">Fuente: https://www.nand2tetris.org/_files/ugd/44046b_7ef1c00a714c46768f08c459a6cab45a.pdf</p>

#### Cógido Fill.asm
```
// Runs an infinite loop that listens to the keyboard input.
// When a key is pressed (any key), the program blackens the screen,
// i.e. writes "black" in every pixel;
// the screen should remain fully black as long as the key is pressed. 
// When no key is pressed, the program clears the screen, i.e. writes
// "white" in every pixel;
// the screen should remain fully clear as long as no key is pressed.

(START)
@BLACKID
M=0

(LOOP)
@i
M=0

@KBD
D=M

@BLACK
D;JNE

@WHITE
0;JMP


(BLACK)
@BLACKID
D=M
@LOOP
D;JNE

@i
D=M
@SCREEN
A=A+D
M=-1
@i
M=M+1
D=M

@8192
D=A-D

@BLACK
D;JGT

@BLACKID
M=1

@LOOP
D;JEQ

(WHITE)
@BLACKID
D=M
@LOOP
D;JEQ

@i
D=M
@SCREEN
A=A+D
M=0
@i
M=M+1
D=M

@8192
D=A-D

@WHITE
D;JGT

@BLACKID
M=0

@LOOP
D;JEQ

```
El ordenador Hack es una plataforma von Neumann. Es una máquina de 16 bits, que consiste una CPU, dos módulos de memoria separados que sirven como memoria de y dos dispositivos de E/S asignados a memoria: una pantalla y un teclado.

El programador Hack es consciente de la existencia de dos espacios de direcciones distintos: una memoria de instrucciones y una memoria de datos. Ambas memorias son de 16 bits de ancho y tienen un espacio de direcciones de 15 bits, lo que significa que el tamaño máximo direccionable de cada memoria es de 32K palabras de 16 bits. 

##### Ahora procedemos a colocar el archivo Fill.asm en el ensamblador para convertirlo a binario y corroboramos si quedó correctamente:

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/ee1ead6e-eb16-489d-840f-8ab9ace6318a" width="450" height="350"/></p>
<p align="center">Fuente: Propiedad de los autores</p>

##### Observamos que se compiló adecuadamente, ahora extraemos el archivo punto hack.

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/ea9d37ce-51ac-4c7e-bc0d-13da2a5d99bf" /></p>
<p align="center">Fuente: Propiedad de los autores</p>

##### Ahora usamos el programa CPUEmulator para corroborar si el codigo que hicimos y convertimos en el archivo punto hack funciona.

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/79f017a2-46e6-4b86-9456-312d204e3428" width="450" height="350" /></p>
<p align="center">Fuente: Propiedad de los autores</p>

##### Realizamos el test de presionar las teclas para corroborar si la pantalla se pone oscura al momento de presionar cualquier tecla y si se pone blanca si no se presiona ninguna.

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/1e1e8d1a-db44-467b-bafd-a8056a97178b" width="450" height="350"/></p>
<p align="center">Fuente: Propiedad de los autores</p>

##### Nos damos cuenta que la pantalla se pone de color negro al momento de presionar cualquier tecla.

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/23fe5076-2888-4ee8-8037-266dff992056b" width="450" height="350"/></p>
<p align="center">Fuente: Propiedad de los autores</p>

##### Nos damos cuenta que la pantalla se queda en blanco se no se presiona ninguna tecla.

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/75b54a47-ca0c-463e-99ba-23d75b3fddfa" width="450" height="350"/></p>
<p align="center">Fuente: Propiedad de los autores</p>

De acuerdo a toda la información aprendida enteriormente nos damos cuenta que la CPU sólo puede ejecutar programas que residan en la memoria de instrucciones, la cual solo sirve para lectura de los dispositivos, y los programas se cargan en ella utilizando algún medios exógenos. Por ejemplo, la memoria de instrucciones puede implementarse en un chip ROM que está pregrabado con el programa requerido. Para cargar un nuevo programa se realiza sustituyendo todo el chip ROM, de forma similar a la sustitución de un cartucho en una videoconsola. consola de juegos. Para simular esta operación, los simuladores de hardware de la plataforma Hack deben proporcionar un medio para cargar la memoria de instrucciones a partir de un archivo de texto que contenga un programa en lenguaje máquina como lo realizamos anteriormente.




