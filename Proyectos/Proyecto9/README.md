<p align="center">  Elaboración Proyecto 9: High-Level Language </p>

<h4 align="center">  ARQUITECTURA DE COMPUTADORES A2 </h4>


<p align="center">  WEB GRUPO ALPHA:
https://diegotoscano04.github.io/  </p>
<p align="center"> <img src= "https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/4f2cd469-f8a6-482a-8f92-33960615841e"> </p>

------------

# Aprendizaje herramienta The Nand to Tetris

## Software:
###### El paquete de software Nand to Tetris contiene todas las herramientas y archivos necesarios para completar todos los proyectos descritos en este sitio y en el libro "The Elements of Computing Systems".

## Descarga:
###### Se descarga el programa Nand2Tetris de la página web: https://www.nand2tetris.org/software
###### Una vez descargados los archivos quedará una carpeta con el nombre de `nand2tetris` con 2 subcarpetas denominadas `projects` y `tools`.
![image](https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/d058171f-9976-4289-bb46-fc4ff46c9729) ![image](https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/417ef519-6948-40a5-9c36-775b71ab4c82)

## Información sobre los archivos:
###### En la carpeta `projects` estarán los proyectos del 1 al 13 los cuales son archivos que deben modificarse para completar las prácticas mientras se trabaja en varios proyectos de nand2tetris.
###### En la carpeta `tools` estarán las herramientas del software nand2tetris.

## Uso del programa VM emulator 
<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/32618071-ced9-417f-b99b-72187e6840d7" width="500" height="300" /></p>
<p align="center">Fuente: https://docs.google.com/presentation/d/1D7zmC6RfaR2GDG385M1pv80Q3UR4PsdC/edit?pli=1#slide=id.p8</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/d17fdb7f-66f7-462e-8e90-8cf84d066091" width="500" height="300" /></p>
<p align="center">Fuente: https://docs.google.com/presentation/d/1D7zmC6RfaR2GDG385M1pv80Q3UR4PsdC/edit?pli=1#slide=id.p8</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/2267978b-e3dd-4555-8c32-16a85fbee744" width="500" height="300" /></p>
<p align="center">Fuente: https://docs.google.com/presentation/d/1D7zmC6RfaR2GDG385M1pv80Q3UR4PsdC/edit?pli=1#slide=id.p8</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/25035db8-6837-4a80-86d0-c3c44337f782" width="500" height="300" /></p>
<p align="center">Fuente: https://docs.google.com/presentation/d/1D7zmC6RfaR2GDG385M1pv80Q3UR4PsdC/edit?pli=1#slide=id.p8</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/71a0d17e-160d-43f6-9535-524176c40585" width="500" height="300" /></p>
<p align="center">Fuente: https://docs.google.com/presentation/d/1D7zmC6RfaR2GDG385M1pv80Q3UR4PsdC/edit?pli=1#slide=id.p8</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/2b988c2c-0dcc-4c83-b0e6-80852b5513cc" width="500" height="300" /></p>
<p align="center">Fuente: https://docs.google.com/presentation/d/1D7zmC6RfaR2GDG385M1pv80Q3UR4PsdC/edit?pli=1#slide=id.p8</p>

## Uso del programa JackCompiler
<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/d45a89fd-bc46-4aa6-ac26-a1276b790a95" /></p>
<p align="center">Fuente: Propiedad de los autores</p>

Se copian los archivos a usar para pasarlos a la carpeta donde está el programa JackCompiler:
<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/58ab0457-d3e5-41d6-9c7d-10a3d02ed46c" /></p>
<p align="center">Fuente: Propiedad de los autores</p>

Se accede al Simbolo de sistema para ejecutar el JackCompiler y hacer que conveirta los archivos `.jack` a `.VM`.
<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/ee2341b8-f697-4f52-a9b1-60283d660dd8"/></p>
<p align="center">Fuente: Propiedad de los autores</p>

Posterior a esto se ejecuta el programa VMEmulator para correr los archivos y mostrar el programa elaborado
<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/f1e8d34a-e512-446a-902e-e9d3aa365001" width="500" height="300" /></p>
<p align="center">Fuente: Propiedad de los autores</p>

### Desarrollo Proyecto 9:

##### En este proyecto se implementará un programa en Jack: Un lenguaje de programación simple, similar a Java, basado en objetos.

## Objetivos Generales

- El objetivo de este proyecto es familiarizarse con el uso del lenguaje jack.

------------

## Objetivos Específicos

- Inventar o asimilar un juego de ordenador sencillo o algún otro programa interactivo, e impleméntelo en el lenguaje Jack. Algunos ejemplos son versiones básicas de Tetris, Snake, Space Invaders, Sokoban, Pong, o juegos más sencillos como el Ahorcado.
-----------

## Pasos para crear un programa en Jack.

0. Crea una carpeta para tu programa. Llamémosla carpeta del programa.
1. Escriba su programa Jack - un conjunto de una o más clases Jack - cada una almacenada en un archivo de texto separado `className.jack`. Mantenga todos estos archivos .jack en la misma carpeta de programa.
2. Compile la carpeta del programa utilizando el compilador Jack suministrado. Esto hará que el compilador compile todas las clases .jack encontradas en la carpeta a los correspondientes archivos .vm, almacenados en la misma carpeta. Si se informa de un error de compilación, depure el programa y vuelva a compilar hasta que no se emita mensajes de error.
3. En este punto, la carpeta del programa debe contener los archivos .jack de origen, junto con los archivos .vm compilados. Para probar el programa compilado, cargue la carpeta del programa en el emulador VM suministrado. A continuación, ejecute el programa en el emulador VM. Si encuentra errores de ejecución o un comportamiento no deseado del programa, corrija el programa y pase a la etapa 2.

#### El Jack OS

Escribir programas Jack requiere trabajar con el sistema operativo Jack, al igual que escribir programas Java requiere trabajar con la biblioteca de clases Java. El SO Jack es un conjunto de librerías que extienden las capacidades del lenguaje básico y cierran las brechas entre éste y el hardware subyacente. Aquí está la API del SO Jack https://www.nand2tetris.org/_files/ugd/44046b_a89c06efcef3491cafb42fb76cc95dc0.pdf, y la lista de códigos de error del SO https://www.nand2tetris.org/_files/ugd/44046b_907fb326cbcb4851b93c21f79d515180.pdf y su significado.
Suministramos dos implementaciones de Jack OS: "nativo", y "builtin". La implementación nativa del SO fue escrita en Jack y luego traducida (usando un compilador Jack) al conjunto de ocho archivos VM almacenados en la carpeta nand2tetris/tools/os. La implementación del sistema operativo incorporado se escribió en Java, y está incrustada en el emulador VM disponible en `nand2tetris/tools`.

#### Recursos para la práctica:

- Herramientas `tools/JackCompiler`, para traducir tu programa a un conjunto de archivos .vm, y  `tools/VMEmulator`, para ejecutar y probar el código compilado.
- La carpeta `projects/09/Square` incluye el código fuente de un programa completo, de 3 clases interactivas. Este programa ilustra varias técnicas de programación que comúnmente son utilizadas en el diseño de aplicaciones que combinan gráficos, animación e interacción con el usuario.

#### Lenguaje Jack:

Un lenguaje sencillo, similar a el lenguaje Java:
- Basado en objetos
- Polivalente
- Se presta para plicaciones interactivas
- Se puede aprender en una hora.

#### Estructura Lenguaje Jack:

 Un programa Jack es una colección de una o más clases Jack, una de las cuales debe ser llamada Main:
 
- La clase Main debe tener al menos una función llamada main
- Punto de entrada del programa: `Main.main`.

#### Tipos de datos:

##### Primitivos:
• int
• char
• boolean

##### Tipos de clases:
• Tipos incorporados, como String
• Tipos definidos por el programador: Definidos y utilizados según las necesidades.

#### Flujo de control:

• if
• while
• do

#### Entrada / salida
- Teclado (clase OS):
Una biblioteca de funciones para leer
del teclado
- Salida (clase OS):
Una biblioteca de funciones para escribir
en la pantalla

#### Una clase Jack:

- Consiste en declaraciones estáticas y declaraciones de subrutinas (constructores, métodos, funciones)
- Todos los campos y variables son privados
- Todas las subrutinas son públicas
- La única forma de acceder a un campo o a una variable static (desde fuera de laclase) es llamando a un método (como getx, gety, ...)

### Variables:

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/dee12db9-cc89-4bcb-9b93-803e376380ae" width="500" height="300" /></p>
<p align="center">Fuente: https://drive.google.com/file/d/1CAGF8d3pDIOgqX8NZGzU34PPEzvfTYrk/view</p>

### Declaraciones:

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/f4f8f6cd-04c1-4ac5-922a-6884011abb52" width="500" height="300" /></p>
<p align="center">Fuente: https://drive.google.com/file/d/1CAGF8d3pDIOgqX8NZGzU34PPEzvfTYrk/view</p>

### Expresiones:

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/21e6194d-2e0b-401d-9a52-7717d35face2" width="500" height="300" /></p>
<p align="center">Fuente: https://drive.google.com/file/d/1CAGF8d3pDIOgqX8NZGzU34PPEzvfTYrk/view</p>

### Strings:

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/f3cc35cf-1810-4660-84f3-d488723ba0d0" /></p>
<p align="center">Fuente: https://drive.google.com/file/d/1CAGF8d3pDIOgqX8NZGzU34PPEzvfTYrk/view</p>

### Arrays:

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/510462f0-1b01-4f39-98c7-241e6d7addd7" /></p>
<p align="center">Fuente: https://drive.google.com/file/d/1CAGF8d3pDIOgqX8NZGzU34PPEzvfTYrk/view</p>

### Clases:

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/37082098-6b0e-4293-8161-e9b56e081aef" /></p>
<p align="center">Fuente: https://drive.google.com/file/d/1CAGF8d3pDIOgqX8NZGzU34PPEzvfTYrk/view</p>

### Subrutinas:
<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/79807a1e-4200-4d68-8469-9617e0c67b8f" /></p>
<p align="center">Fuente: https://drive.google.com/file/d/1CAGF8d3pDIOgqX8NZGzU34PPEzvfTYrk/view</p>

### Jack OS:

- Una colección de clases Jack.
- Similar a la biblioteca de clases de Java.

### Clases OS:

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/d6fff043-3a20-4f87-9d8b-ece013dd4959" /></p>
<p align="center">Fuente: https://drive.google.com/file/d/1CAGF8d3pDIOgqX8NZGzU34PPEzvfTYrk/view</p>

### Ejemplos de aplicaciones simples con jack:

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/40717abe-7764-438f-b4f7-616ab009a375" /></p>
<p align="center">Fuente: https://drive.google.com/file/d/1CAGF8d3pDIOgqX8NZGzU34PPEzvfTYrk/view</p>

### Perspectivas:

Jack es un lenguaje sencillo, Con elementos esenciales de:
- Programación procedimental
- Programación Orienta a Objetos

### Limitaciones:

- Pocas estructuras de control
- Sintaxis peculiar
- Sin herencia

### Tipos de datos
- Sistema de tipos primitivo
- Tipado débil: para dar al programador el control total, especialmente para escribir el sistema operativo.

### Diseño propuesto:

#### QuickSort:

Funcionamiento del algoritmo:

- Elegir un elemento del conjunto de elementos a ordenar, al que llamaremos pivote.
- Resituar los demás elementos de la lista a cada lado del pivote, de manera que a un lado queden todos los menores que él, y al otro los mayores. Los elementos iguales al pivote pueden ser colocados tanto a su derecha como a su izquierda, dependiendo de la implementación deseada. En este momento, el pivote ocupa exactamente el lugar que le corresponderá en la lista ordenada.
- La lista queda separada en dos sublistas, una formada por los elementos a la izquierda del pivote, y otra por los elementos a su derecha.
- Repetir este proceso de forma recursiva para cada sublista mientras éstas contengan más de un elemento. Una vez terminado este proceso todos los elementos estarán ordenados.


<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/490e0a8c-d639-4ac6-8a0d-582169f8bd39" /></p>
<p align="center">Fuente: https://es.wikipedia.org/wiki/Quicksort</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/444f6d06-7752-4dcb-98ed-839f8cdb3a7b" /></p>
<p align="center">Fuente: https://es.wikipedia.org/wiki/Quicksort</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/be4ee2bc-f964-4a59-81de-253902cac65b" /></p>
<p align="center">Fuente: https://es.wikipedia.org/wiki/Quicksort</p>

### Visualización archivo `Main.jack`:

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/2f0d2bcc-384b-4d78-a9b4-d792f352e375"/></p>
<p align="center">Fuente: Propeidad de los autores</p>

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/eb2c6337-1a7a-4e0c-b5b4-3f6654af8c52"/></p>
<p align="center">Fuente: Propeidad de los autores</p>

### Obtención de Archivo `Main.vm`

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/ad6209f5-5933-4b38-8456-3aff32ea8ec7"/></p>
<p align="center">Fuente: Propeidad de los autores</p>

###  Vistazo Archivo `Main.vm`

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/34be576b-6696-48ec-8346-fad2383acaa9"/></p>
<p align="center">Fuente: Propeidad de los autores</p>

### Funcionamiento Proyecto QuickSort en Jack:

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/61f6834f-75cb-4db0-bace-93646b44a8b9"  width="700" height="500"/></p>
<p align="center">Fuente: Propeidad de los autores</p>


### Demostración con el ordenamiento de un Array:

<p align="center"><img src="https://github.com/DiegoToscano04/DiegoToscano04.github.io/assets/129452906/2a86655e-a56d-48c1-b820-5b2d663a224d"/></p>
<p align="center">Fuente: Propeidad de los autores</p>


### Pregunta:

¿Qué se debe considerar para proponer un nuevo y buen lenguaje de programación, teniendo en cuenta la arquitectura de computador completa? Justifique su respuesta.

Un nuevo y buen lenguaje de programación, considerando la arquitectura de computador completa, tiene varios aspectos clave a tener en cuenta:

• Abstracción y portabilidad: El nuevo lenguaje debe ofrecer abstracciones que permitan a los programadores escribir código independientemente de la arquitectura subyacente. Esto implica un alto nivel de portabilidad para que el código pueda ejecutarse eficientemente en diferentes plataformas y sistemas.
• Eficiencia y optimización: El lenguaje debe permitir la optimización del código para aprovechar al máximo los recursos del hardware, incluyendo la capacidad de realizar operaciones de bajo nivel cuando sea necesario para maximizar el rendimiento.
• Seguridad y fiabilidad: Debe proporcionar herramientas y características que minimicen errores, como la gestión automática de la memoria para prevenir fugas o errores de acceso, y la detección de errores en tiempo de compilación o ejecución.
• Soporte para paradigmas modernos: El nuevo lenguaje debe ser capaz de adaptarse a los paradigmas de programación modernos, como la programación concurrente, funcional o orientada a objetos, brindando soporte adecuado para facilitar el desarrollo de aplicaciones complejas.
• Facilidad de aprendizaje y legibilidad: Debe tener una sintaxis clara y coherente que facilite su aprendizaje y comprensión, permitiendo a los programadores expresar sus ideas de manera eficiente y legible. 

La propuesta de un nuevo y buen lenguaje de programación que considere la arquitectura de computador completa debe equilibrar la abstracción de detalles de bajo nivel con la capacidad de optimización, portabilidad, seguridad, soporte a paradigmas modernos y facilidad de uso para los programadores. Su diseño debe ser cuidadoso y considerado, abordando las necesidades de desarrollo de software en la actualidad y en el futuro, manteniendo un equilibrio entre la simplicidad y la potencia.







